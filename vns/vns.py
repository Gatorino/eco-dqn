import os
import time

import matplotlib.pyplot as plt
import numpy as np

from src.envs.utils import (RandomBarabasiAlbertGraphGenerator,
                            EdgeType)


def vns(initial_solution: np.ndarray, adjacency_matrix: np.ndarray, n_sets: int, k_max: int = 12) -> np.ndarray:
    """
        Runs the Variable Neighborhood Search.

        Args:
            initial_solution (np.ndarray): The initial solution given to vns that will be improved.
            adjacency_matrix (np.ndarray): The adjacency matrix of the current graph.
            n_sets (int): The number of sets of the searched solution.
            k_max (int): The furthest distance the algorithm will jump to find neighbors.

        Returns:
            np.ndarray: The best found solution by the vns algorithm
        """
    searching = True
    current_solution = initial_solution
    current_cut = compute_cut(current_solution, adjacency_matrix)
    nb_solutions = 0
    while searching:
        searching = False
        # Run through the neighborhoods and generate optimized neighbor solutions
        for k in range(1, k_max):
            nb_solutions += 1
            neighbor_solution = generate_random_solution(
                current_solution, n_sets, k)
            optimized_neighbor = local_search(
                neighbor_solution, adjacency_matrix, n_sets)
            optimized_neighbor_cut = compute_cut(
                optimized_neighbor, adjacency_matrix)
            # Update best solution and cut if something better is found
            if optimized_neighbor_cut > current_cut:
                current_solution = optimized_neighbor
                current_cut = optimized_neighbor_cut
                searching = True
                break
            else:
                k += 1
    # print("Number of solutions generated by vns :", nb_solutions)
    return current_solution


def generate_random_solution(initial_solution, n_sets, k):
    """
    Generates a random solution from the initial solution at a distance k.

    Parameters:
    initial_solution (numpy.ndarray): The initial solution to be changed.
    n_sets (int): The number of sets to split the solution in.
    k (int): The distance between the two solutions.

    Returns:
    numpy.ndarray: The generated neighbor array.
    """
    # Initialize the random neighbor
    random_solution = initial_solution.copy()

    # Choose randomly vertices to change
    changed_vertices = np.random.choice(
        np.arange(len(initial_solution)), size=k, replace=False)

    # Update the random neighbor
    for idx in changed_vertices:
        new_set = np.random.randint(0, n_sets)
        # Avoid going back to the initial set
        while new_set == initial_solution[idx]:
            new_set = np.random.randint(0, n_sets)
        random_solution[idx] = new_set
    return random_solution


def local_search(solution, adjacency_matrix, n_sets):
    """
    Computes the local optimal solution given an initial solution

    Args:
        solution (np.ndarray): The array of sets initially corresponding to each vertex.
        adjacency_matrix (np.ndarray): The adjacency matrix of the current graph.
        n_sets(int): The number of sets the solution is split in.

    Returns:
        np.ndarray: The locally optimal solution
    """
    change = True
    while change:
        change = False
        while not change:
            for v_idx, v_set in enumerate(solution):
                # Flow to the current set
                current_flow = compute_flow(
                    adjacency_matrix, v_idx, v_set, solution)
                first_set = True
                # Compute the flow to all the other sets
                for set_idx in range(n_sets):
                    # Skip current set
                    if set_idx == v_set:
                        continue
                    if first_set:
                        best_flow_to_other_set = compute_flow(
                            adjacency_matrix, v_idx, set_idx, solution)
                        best_target_set = set_idx
                        first_set = False
                    else:
                        flow_to_other_set = compute_flow(
                            adjacency_matrix, v_idx, set_idx, solution)
                        if flow_to_other_set > best_flow_to_other_set:
                            best_flow_to_other_set = flow_to_other_set
                            best_target_set = set_idx
                if best_flow_to_other_set > current_flow:
                    solution[v_idx] = best_target_set
                    change = True
            # If the loop went through all nodes and didn't change any of them, the solution is locally optimal
            if change == False:
                return solution


def compute_flow(adjacency_matrix: np.ndarray, initial_vertex: int, target_set: int, current_solution: np.ndarray) -> float:
    """
    Computes the flow from the initial vertex to a target set.

    Args:
        adjacency_matrix (np.ndarray): The adjacency matrix of the current graph.
        initial_vertex (int): A vertex belonging to a set.
        target_set (int): The target set of the computation of the flow.
        current_solution (np.ndarray): The array of sets of corresponding to each vertex.

    Returns:
        float: The flow from the vertex to the target set.
    """
    flow = 0
    weights = adjacency_matrix[initial_vertex]
    for v in range(len(adjacency_matrix)):
        if current_solution[v] != target_set:
            flow += weights[v]

    return flow


def compute_cut(solution: np.ndarray, adjacency_matrix: np.ndarray) -> float:
    """
    Computes the cut of a given solution.

    Args:
        adjacency_matrix (np.ndarray): The adjacency matrix of the current graph.
        solution (np.ndarray): An array with the set membership of each vertex for that solution.

    Returns:
        float: The cut value of the solution for the adjacency matrix.
    """
    # Runs computation of cuts through the upper triangular matrix
    cut_value = 0
    for i in range(len(adjacency_matrix)):
        for j in range(i+1, len(adjacency_matrix)):
            if solution[i] != solution[j]:
                cut_value += adjacency_matrix[i][j]

    return cut_value


def distance(solution1, solution2):
    """
    Computes the disntace between two solutions

    Args:
        solution1 (np.ndarray): An array corresponding to the set membership of each node.
        solution2 (np.ndarray): An array corresponding to the set membership of each node.

    Returns:
        The distance between the two solutions.
        The distance increases by 1 if the set of one node is different in the two solutions.
    """
    return np.count_nonzero(solution1 != solution2)


def run(save_loc="vns/results"):

    print("\n----- Running {} -----\n".format(os.path.basename(__file__)))

    ####################################################
    # SET UP ENVIRONMENTAL AND VARIABLES
    ####################################################

    n_spins_train = 500
    n_sets = 5

    ####################################################
    # SET UP TRAINING AND TEST GRAPHS
    ####################################################

    train_graph_generator = RandomBarabasiAlbertGraphGenerator(
        n_spins=n_spins_train, m_insertion_edges=4, edge_type=EdgeType.DISCRETE)

    matrix = train_graph_generator.get()

    #############
    # INITIALIZE STATE
    #############
    # np.random.seed(1)
    state = np.zeros(n_spins_train)
    state[:] = np.array(np.random.randint(n_sets, size=n_spins_train,))

    #############
    # RUN VNS
    #############
    start = time.time()
    solution = vns(state, matrix, n_sets=n_sets, k_max=10)
    print(time.time() - start)
    # solution10 = vns(state, matrix, n_sets=3, k_max=10)
    # solution15 = vns(state, matrix, n_sets=3, k_max=15)

    # # print(f"Final solution is {solution}")
    print(compute_cut(solution, matrix))
    # print(compute_cut(solution10, matrix))
    # print(compute_cut(solution15, matrix))
    # for k in range(1, 20):
    #     solution = vns(state, matrix, n_sets=3, k_max=k)
    #     print(compute_cut(solution, matrix), distance(state, solution))


if __name__ == "__main__":
    run()
